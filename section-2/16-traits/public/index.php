<?php echo '<pre>';

require_once __DIR__ . '/../vendor/autoload.php';

$coffeeMaker = new \App\CoffeeMaker();
$coffeeMaker->makeCoffee();

$latteMaker = new \App\LatteMaker();
$latteMaker->makeCoffee();
$latteMaker->makeLatte();

$cappuccinoMaker = new \App\CappuccinoMaker();
$cappuccinoMaker->makeCoffee();
$cappuccinoMaker->makeCappuccino();

// Трейты позволяют использовать код повторно и обходить ограничение множественного наследования в PHP
// С помощью use трейты подключается в классы или в другие трейты. Нельзя создавать экземпляры трейтов

$allInOneCoffeeMaker = new \App\AllInOneCoffeeMaker();
$allInOneCoffeeMaker->makeCoffee();
$allInOneCoffeeMaker->makeLatte();
$allInOneCoffeeMaker->makeCappuccino();

// Фактически при подключении трейта его код просто копируется и вставляется в класс или в другой трейт

// Метод, определенный в трейте, может быть переопределен, если класс имеет метод с таким же именем
// Метод класса будет иметь больший приоритет при вызове

// Но если трейт подключен в дочернем классе и имеет метод с таким же именем, как в родительском,
// то в этом случае, естественно, метод из трейта будет иметь больший приоритет

// Если в используемых трейтах есть конфликтующие методы с одним именем, то необходимо выбрать,
// к какому трейту нужно обращаться при вызове метода с помощью instead of
// Также это можно решить с помощью присвоения псевдонима методу конкретного трейта

$allInOneCoffeeMaker->makeOriginalLatte();  // См. файл AllInOneCoffeeMaker.php

// Если метод в трейте является private, то его видимость можно изменить
// При использовании трейта в классе необходимо использовать as public в фигурных скобках
// Но это не самая лучшая практика, и следует избегать использования этой возможности

// Кроме методов в трейтах также можно определять свойства
// И свойства с одинаковыми именами в классе и трейте также будут конфликтовать

// Трейты могут иметь абстрактные методы
// Если в классе есть хотя бы один абстрактный метод, то весь класс должен быть абстрактным
// Но если абстрактный метод находится в трейте, то не нужно помечать весь класс как абстрактный
// Использование абстракций в трейтах не очень хорошая практика, лучше использовать сеттеры

// Трейты также могут иметь статические свойства и методы

\App\LatteMaker::foo();
echo \App\LatteMaker::$x;

// Если трейт имеет статическое свойство, то каждый класс, использующий этот трейт,
// будет иметь независимый экземпляр этого свойства, в отличие от наследования, где статическое свойство общее

// Константа __CLASS__ в трейте выведет имя класса, в котором этот трейт используется

// Трейты не следует использовать ни для чего, кроме простого повторного использования кода.
// Следует избегать использования в трейтах абстрактных методов.
// Абстрактный метод это как бы контракт. А для обеспечения контрактов есть интерфейсы и абстрактные классы.

// Использование final для метода в трейте все равно позволит переопределять этот метод
// В трейте нельзя изменить видимость метода, но в классе с этим трейтом можно сделать его методы public, что странно

// Трейты полезны для использования общего функционала в классах, не связанных друг с другом

$customer = new \App\Customer();
$invoice = new \App\Invoice();

$customer->updateProfile();
$invoice->process();